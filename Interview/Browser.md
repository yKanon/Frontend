### 1. 简单介绍一下v8引擎的垃圾回收机制

v8的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说搜两个特点。

1. 新生的对象容易早死
2. 不死的对象会活得更久

基于这个假说，v8引擎将内存分为了新生代和老生代。新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。

新生代被分为From和To两个空间，To一般是闲置的。当From空间满了的时候会执行Scavenge算法进行垃圾回收。将我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：

* 检查From空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升老生代。如果不满足则移动To空间。
* 如果对象不存活，则释放对象的空间
* 最后将From空间和To空间角色进行交换

新生代对象晋升到老生代有两个条件：

* 第一个是判断是否已经经历过一次scavenge回收。若经历过，则将对象从From空间复制到老生代中；若没有经历，则复制到To空间。
* 第二个是To空间的内存使用占比是否超过限制。当对象从From空间到To空间时，若To空间使用超过25%，则对象直接晋升老生代。设置25%的原因主要是因为算法结束后，两个空间结束后会交换位置，如果To空间的内存太小，会影响后续的内存分配。

老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清楚后会造成很多的内存碎片，不便于后面的内存分配。所以为了解决内存碎片的问题引入了标记压缩法。

由于来进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，对于新生代方法，由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。为了解决这个问题v8引入了增量标记的方法，将每一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。



### 2. 哪些操作会造成内存泄漏？

1. 意外的全局变量。由于我们使用未声明的变量，而意外的创建了一个全局变量，而这个变量一直留在内存中，无法被回收。
2. 被遗忘的计时器或回调函数。我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。
3. 脱离DOM的引用。我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。
4. 闭包。不合理的使用闭包，从而导致某些变量一直被留在内存当中。



### 3. 需求： 实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？

通过使用pushState+ajax实现浏览器无刷新前进后退，当一次ajax调用成功后，我们将一条state记录加入到history对象中。一条state记录包含了url、title和content属性，在popState事件中可以获取到这个state对象，我们可以使用content来传递数据。最后我们通过对window.onPopState事件监听来响应浏览器的前进后退操作。

问题：

1. 打开首页时没有记录，我们可以使用replaceState来将首页的记录替换
2. 当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的url，需要后端的配合将其重定向到一个页面。



### 4. 如何判断当前脚本运行在浏览器还是node环境中？

```  
this === window ? 'browser' : 'node'

通过判断Global对象是否为window，如果不为window，当前脚本便不是运行在浏览器中。
```



### 5. 什么是前端路由？什么时候适合使用前端路由？前端路由有哪些优缺点？

根据url的不同映射不同的内容。之前是服务器根据不同的url返回不同的页面实现的。

在单页面应用中，大部分页面结构不变，只改变部分内容的时候使用。

优点：体验好，不需要每次都从服务器获取新页面，页面切换迅速。

缺点：单页面无法记住之前滚动的位置，无法在前进、后退的时候记住滚动位置。

前端路由一共有两种实现方式，一种是通过hash的方式，一种是pushState的方式



###   6. 检测浏览器版本有哪些方式？

* 检测window.navigator.userAgent的值。这种方式不可靠，因为userAgent可以被改写
* 根据每个浏览器特有的特性来判断，如ie下的ActiveXObject



### 7. 什么是Polyfill？

指的是用于实现浏览器并不支持的原生API的代码。

比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览
器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么
这就可以称为一个 Polyfill。

一个shim是一个库，有自己的 API，而不是单纯实现原生不支持的API。



### 8. 